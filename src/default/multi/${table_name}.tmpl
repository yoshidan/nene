// DON'T EDIT. this code is generated by nene.
use google_cloud_googleapis::spanner::v1::Mutation;
use google_cloud_spanner::client::Error;
use google_cloud_spanner::key::Key;
use google_cloud_spanner::mutation::{
    delete, insert_or_update_struct, insert_struct, replace_struct, update_struct,
};
use google_cloud_spanner::row::{Error as RowError, Row};
use google_cloud_spanner::statement::Statement;
use google_cloud_spanner::transaction::Transaction;
use google_cloud_spanner::transaction::CallOptions;
use google_cloud_spanner_derive::Table;
use std::convert::TryFrom;

pub const TABLE_NAME: &str = "{{{ table_name }}}";
{{ #each columns }}
pub const COLUMN_{{{ upper_snake this.column_name }}}: &str = "{{{ this.column_name }}}";
{{ /each }}

#[derive(Debug,Clone,Table{{#if (eq json true)}},serde::Serialize,serde::Deserialize{{/if}})]
pub struct {{{ table_name }}} {
    {{ #each columns }}
    {{ #if (eq @root.json true) }}
        {{ #if (eq this.spanner_type "TIMESTAMP") }}
    #[serde({{#if this.nullable }}default,{{/if }}with = "time::serde::rfc3339{{#if this.nullable }}::option{{/if }}")]
        {{/if }}
    {{/if }}
    #[spanner(name = "{{this.column_name}}"{{ #if this.allow_commit_timestamp ~}},commitTimestamp{{/if}})]
    pub {{{ snake this.column_name }}}: {{ #if this.nullable }}Option<{{ /if }}{{{ rust_type this.spanner_type }}}{{ #if this.nullable }}>{{ /if }},
    {{ /each }}
}

{{#if (eq default true) ~}}
impl Default for {{{ table_name }}} {
    fn default() -> Self {
        Self {
            {{ #each columns }}
            {{{ snake this.column_name }}}: {{{ rust_default this.nullable this.spanner_type }}},
            {{ /each }}
        }
    }
}
{{/if ~}}

impl {{{ table_name }}} {
    pub fn insert(&self) -> Mutation {
        insert_struct(TABLE_NAME, &self)
    }

    pub fn update(&self) -> Mutation {
        update_struct(TABLE_NAME, &self)
    }

    pub fn replace(&self) -> Mutation {
        replace_struct(TABLE_NAME, &self)
    }

    pub fn insert_or_update(&self) -> Mutation {
        insert_or_update_struct(TABLE_NAME, &self)
    }

    pub fn delete(&self) -> Mutation {
        delete(TABLE_NAME, {{ #if composite_key }}Key::composite(&[{{ #each primary_keys }}{{#if (gt @index 0)}}, {{/if}}&self.{{{ snake this.column.column_name }}}{{ /each }}]){{ else }}Key::new({{ #each primary_keys }}&self.{{{ snake this.column.column_name }}}{{ /each }}){{ /if }})
    }

    async fn read_by_statement(tx: &mut Transaction, stmt: Statement, options: Option<CallOptions>) -> Result<Vec<Self>, Error> {
        let mut reader = tx.query(stmt).await?;
        if options.is_some() {
            reader.set_call_options(options.unwrap());
        }
        let mut result = vec![];
        while let Some(row) = reader.next().await? {
            result.push(row.try_into()?);
        }
        Ok(result)
    }

    {{ #each primary_keys }}
    {{ #if last }}
    pub async fn find_by_pk(
       tx: &mut Transaction{{ #each this.uppers }}, {{{ snake this.column_name }}}: {{{ rust_arg_type (rust_type this.spanner_type) }}}{{/each}}, options: Option<CallOptions>
    ) -> Result<Option<Self>, Error> {
         let mut stmt = Statement::new("SELECT * From {{{ @root.table_name }}}{{ #each this.uppers }}{{#if (eq @index 0)}} WHERE {{else}} AND {{/if}}{{{ this.column_name }}} = @{{{ this.column_name }}}{{/each}}");
         {{ #each this.uppers }}
         stmt.add_param(COLUMN_{{{ upper_snake this.column_name }}}, {{#if (eq (rust_type this.spanner_type) "String") }}&{{ /if }}{{{ snake this.column_name }}});
         {{/each}}
         let mut rows = Self::read_by_statement(tx, stmt, options).await?;
         if !rows.is_empty() {
            Ok(rows.pop())
         } else {
            Ok(None)
         }
    }
    {{ else }}
    pub async fn read_by{{ #each this.uppers }}_{{{ snake this.column_name }}}{{/each}}(
       tx: &mut Transaction{{ #each this.uppers }}, {{{ snake this.column_name }}}: {{{ rust_arg_type (rust_type this.spanner_type) }}}{{/each}}, options: Option<CallOptions>
    ) -> Result<Vec<Self>, Error> {
         let mut stmt = Statement::new("SELECT * From {{{ @root.table_name }}}{{ #each this.uppers }}{{#if (eq @index 0)}} WHERE {{else}} AND {{/if}}{{{ this.column_name }}} = @{{{ this.column_name }}}{{/each}}");
         {{ #each this.uppers }}
         stmt.add_param(COLUMN_{{{ upper_snake this.column_name }}}, {{#if (eq (rust_type this.spanner_type) "String") }}&{{ /if }}{{{ snake this.column_name }}});
         {{/each}}
         Self::read_by_statement(tx, stmt, options).await
    }
    {{ /if }}
    {{ /each }}
}
